# Disclaimer: This script was generated by an AI language model
# using GPT-5.1-Codex-Max

import pandas as pd
import numpy as np

rng = np.random.default_rng(42)


def clean_title(s: str) -> str:
    """Lowercase and strip to alnum + spaces to improve matching."""
    cleaned = "".join(ch.lower() if ch.isalnum() else " " for ch in s)
    return " ".join(cleaned.split())


# ---------------------------
# Load game data (vgsales only)
# ---------------------------
sales = pd.read_csv("../data/vgsales.csv")
sales = sales.dropna(subset=["Name", "Genre", "Platform"])
sales["title_norm"] = sales["Name"].str.strip().str.lower()
sales["title_clean"] = sales["Name"].apply(clean_title)

# Deduplicate by title/platform, keeping the first occurrence
sales = sales.drop_duplicates(subset=["title_clean", "Platform"]).reset_index(drop=True)


# Build the working games dataframe using only vgsales attributes
def parse_year(val):
    if pd.isna(val):
        return np.nan
    try:
        return int(float(val))
    except Exception:
        return np.nan


games_all = pd.DataFrame(
    {
        "game_title": sales["Name"],
        "Platform": sales["Platform"],
        "Genre": sales["Genre"],
        "release_year": sales["Year"].apply(parse_year),
        "publisher": sales.get("Publisher"),
        "global_sales": sales.get("Global_Sales"),
        "title_norm": sales["title_norm"],
        "title_clean": sales["title_clean"],
    }
)

# Categorical distributions from the dataset
genre_probs = games_all["Genre"].value_counts(normalize=True)
platform_probs = games_all["Platform"].value_counts(normalize=True)
age_group_probs = pd.Series([0.2, 0.5, 0.3], index=["Kids", "Teen", "Adult"])


def weighted_choice(vc_series, size=1):
    """Sample from a value_counts() series (index = values, values = probs)."""
    return rng.choice(vc_series.index.to_list(), size=size, p=vc_series.values)


def skew_distribution(vc_series, exponent=1.4):
    """Amplify the most common categories to create a skewed distribution."""
    weights = np.power(vc_series.values, exponent)
    weights = weights / weights.sum()
    return pd.Series(weights, index=vc_series.index)


# ---------------------------
# Generate players (ensure coverage) and assignments
# ---------------------------

reviews_per_game_required = 3
reviews_per_user_cap = 5

games_by_genre = {g: games_all[games_all["Genre"] == g] for g in genre_probs.index}
games_count_by_genre = {g: len(df) for g, df in games_by_genre.items()}

# Minimum players per genre to satisfy coverage assuming each writes 5 reviews
min_players_per_genre = {
    g: int(np.ceil(reviews_per_game_required * cnt / reviews_per_user_cap))
    for g, cnt in games_count_by_genre.items()
}

users = []
platform_probs_skewed = skew_distribution(platform_probs, exponent=1.6)


def add_user(primary_genre):
    uid = len(users) + 1
    age_group = weighted_choice(age_group_probs, size=1)[0]
    sessions = rng.integers(2, 7) if rng.random() < 0.75 else rng.integers(7, 15)
    avg_len = float(np.clip(rng.normal(loc=2.0, scale=0.7), 0.5, 6.0))
    preferred_platform = weighted_choice(platform_probs_skewed, size=1)[0]
    users.append(
        {
            "user_id": uid,
            "age_group": age_group,
            "session_count_per_week": sessions,
            "avg_session_length_hours": avg_len,
            "primary_genre": primary_genre,
            "preferred_platform": preferred_platform,
            "remaining_slots": reviews_per_user_cap,
            "assigned_games": [],
        }
    )
    return uid


# Seed required users per genre
for genre, needed in min_players_per_genre.items():
    for _ in range(needed):
        add_user(genre)

# Add a buffer of extra users distributed by genre popularity
extra_users = 2000
for _ in range(extra_users):
    add_user(weighted_choice(genre_probs, size=1)[0])

# Map genre to list of user indices for quick access
genre_to_users = {}
for idx, user in enumerate(users):
    genre_to_users.setdefault(user["primary_genre"], []).append(idx)

# Track review counts per game
game_review_counts = np.zeros(len(games_all), dtype=int)


# Helper to round-robin through users in a genre
def assign_mandatory_reviews():
    for genre, games_df in games_by_genre.items():
        game_indices = games_df.index.tolist()
        user_indices = genre_to_users.get(genre, [])
        pointer = 0
        for gi in game_indices:
            for _ in range(reviews_per_game_required):
                # find next user with capacity; if none, create a new one
                start_pointer = pointer
                while (
                    not user_indices
                    or users[user_indices[pointer]]["remaining_slots"] <= 0
                ):
                    pointer = (pointer + 1) % max(len(user_indices), 1)
                    if pointer == start_pointer and user_indices:
                        # all full, add a new user for this genre
                        new_uid = add_user(genre)
                        user_indices.append(new_uid - 1)
                        genre_to_users[genre].append(new_uid - 1)
                        start_pointer = pointer = len(user_indices) - 1
                        break
                    if not user_indices:
                        new_uid = add_user(genre)
                        user_indices.append(new_uid - 1)
                        genre_to_users[genre] = user_indices
                        start_pointer = pointer = 0
                        break
                user_idx = user_indices[pointer]
                users[user_idx]["assigned_games"].append(gi)
                users[user_idx]["remaining_slots"] -= 1
                game_review_counts[gi] += 1
                pointer = (pointer + 1) % len(user_indices)


assign_mandatory_reviews()

# Fill remaining slots per user within their genre, favoring less-reviewed games and platform preference
for user in users:
    remaining = user["remaining_slots"]
    if remaining <= 0:
        continue
    genre = user["primary_genre"]
    games_df = games_by_genre[genre]
    if games_df.empty:
        continue
    already = set(user["assigned_games"])
    candidate_indices = [idx for idx in games_df.index if idx not in already]
    if not candidate_indices:
        continue
    # weights: inverse of current review count, platform bonus
    counts = game_review_counts[candidate_indices]
    weights = 1 / (1 + counts.astype(float))
    weights *= np.where(
        games_all.loc[candidate_indices, "Platform"].values
        == user["preferred_platform"],
        2.0,
        1.0,
    )
    weights = weights / weights.sum()
    picks = rng.choice(
        candidate_indices,
        size=min(remaining, len(candidate_indices)),
        replace=False,
        p=weights,
    )
    for gi in picks:
        user["assigned_games"].append(gi)
        user["remaining_slots"] -= 1
        game_review_counts[gi] += 1

# Build players dataframe
players = pd.DataFrame(
    {
        "user_id": [u["user_id"] for u in users],
        "age_group": [u["age_group"] for u in users],
        "session_count_per_week": [u["session_count_per_week"] for u in users],
        "avg_session_length_hours": [
            round(u["avg_session_length_hours"], 2) for u in users
        ],
        "primary_genre": [u["primary_genre"] for u in users],
        "preferred_platform": [u["preferred_platform"] for u in users],
    }
)

players.to_csv("../data/players.csv", index=False)
print("Generated players.csv with", len(players), "users")

# ---------------------------
# Generate player game libraries
# ---------------------------

player_game_rows = []

for user in users:
    assigned_indices = user["assigned_games"]
    if not assigned_indices:
        continue
    g = games_all.loc[assigned_indices].reset_index()
    # Preference score based on platform match
    score = np.where(g["Platform"] == user["preferred_platform"], 2.0, 1.0).astype(
        float
    )
    score = np.clip(score, 1e-6, None)
    score_norm = (score - score.min()) / (score.max() - score.min() + 1e-9)
    multipliers = 0.5 + score_norm  # 0.5â€“1.5
    base_hours = rng.normal(loc=10, scale=5, size=len(g))
    playtime_hours = np.clip(base_hours * multipliers, 0.5, 500)
    rating_base = 3.0 + 1.0 * (score_norm - 0.5)
    rating_noise = rng.normal(loc=0.0, scale=0.7, size=len(g))
    player_rating = rating_base + rating_noise
    for i, row in g.iterrows():
        rating_adj = 0.35 if row["Genre"] == user["primary_genre"] else 0.0
        final_rating = np.clip(float(player_rating[i] + rating_adj), 1.0, 5.0)
        player_game_rows.append(
            {
                "user_id": user["user_id"],
                "game_title": row["game_title"],
                "platform": row["Platform"],
                "genre": row["Genre"],
                "release_year": row["release_year"],
                "publisher": row.get("publisher", np.nan),
                "global_sales": row.get("global_sales", np.nan),
                "playtime_hours": float(playtime_hours[i]),
                "player_rating": round(final_rating, 2),
            }
        )

player_games = pd.DataFrame(player_game_rows)
player_games.to_csv("../data/player_games.csv", index=False)
print("Generated player_games.csv with", len(player_games), "rows")
